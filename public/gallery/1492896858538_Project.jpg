module PCCircuit(NewPC,PCSrc,BranchOutcome,NormalOutCome);
input [31:0] BranchOutcome,NormalOutCome;
input PCSrc;
output [31:0] NewPC;
assign NewPC = (PCSrc==0) ? NormalOutCome : BranchOutcome;
endmodule


module IM(out,Address,clk);
//Our Memory is byte addressable, thus, we should load 4 consecutive words in a 32-bit register.
//Since Our Memory is byte addressable, so the words are bytes, but we would simulate it here in the implementation as the word is 32 bits, as a consequence
//The size of the memory will be shrunk.
parameter imSize= 2 **14; 
input [31:0] Address;
input clk;
output [31:0] out;
reg [31:0] out;
reg [31:0] instructions [imSize-1:0];
reg [31:0] addressAfterModifications;

always @(posedge clk)
begin
addressAfterModifications = Address >> 2;
out = instructions[addressAfterModifications];
end

endmodule

module registerFile(clk, read_reg_1, read_reg_2, write_reg, write_data, regWrite, read_data_1, read_data_2);
input clk;
input [4:0] read_reg_1, read_reg_2, write_reg;
input [31:0] write_data;
input regWrite;

output [31:0] read_data_1, read_data_2;
reg [31:0] read_data_1, read_data_2;
reg [31:0] registers[31:0];// the first square brackets indicates the size of each element in the array, the second square brackets indicates the size of the array itself.

always @ (read_reg_1 or read_reg_2)
begin
if(~ regWrite)
begin
	read_data_1 <= (read_reg_1==0)? 32'b0 : registers[read_reg_1];
	read_data_2 <= (read_reg_2==0)? 32'b0 : registers[read_reg_2];
end
end

always @(posedge clk)
begin
if(regWrite)
begin
	registers[write_reg] <= write_data;
end
end

endmodule

module ALU (Out,ZeroFlag,In1,In2,ALUOP);
input [31:0] In1, In2;
input [2:0] ALUOP;
output reg [31:0] Out;
output reg ZeroFlag;

always @(In1 or In2 or ALUOP)
begin
if(In1==In2)
	ZeroFlag = 1;
else
	ZeroFlag = 0 ;
end

always @(In1 or In2 or ALUOP)
begin
case(ALUOP)
0: Out = In1 + In2;
1: Out = In1 - In2;
2: Out = In1 & In2;
3: Out = In1 | In2;
4: Out = In1 << In2; //Shift left
5: Out = In1 >> In2; //Shift right
6: Out = In1 < In2; //It checks whether input 1 is less than input 2 or not
endcase
end

endmodule



module SignExtend (in, out);
//To support I-format instructions.
input [15:0] in;
output [31:0] out;
assign out[15:0] = in[15:0];
assign out[31:16] = in[15];
endmodule



module DM(read_data, address, write_data, MemRead,MemWrite,clk);
//We would apply the same concept of dividing and simulating the data memory as applied in the Instruction memory
parameter dmSize= 2 **14; 
input [31:0] address,write_data;
input MemRead,MemWrite,clk;
output [31:0] read_data;
reg [31:0] read_data;
reg [31:0] data [dmSize-1:0];
reg [31:0] addressAfterModifications;

always @(posedge clk)
begin
if(MemRead)
begin
	addressAfterModifications = address >> 2;'
	read_data = data[addressAfterModifications];
end
if(MemWrite)
begin
	addressAfterModifications = address >> 2;'
	data[addressAfterModifications] = write_data;
end
else
begin
read_data = 32'bz;
end
end

endmodule










































